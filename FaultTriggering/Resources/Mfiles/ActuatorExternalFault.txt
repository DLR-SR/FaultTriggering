#1
char Aclass(3,20)
Adymosim
1.4
Generated by Dymosim


#    Experiment parameters
double experiment(7,1)
       0                   # StartTime    Time at which integration starts
                           #              (and linearization and trimming time)
       0                   # StopTime     Time at which integration stops
       0                   # Increment    Communication step size, if > 0
     100                   # nInterval    Number of communication intervals, if > 0
  1.000000000000000E-004   # Tolerance    Relative precision of signals for
                           #              simulation, linearization and trimming
       0                   # MaxFixedStep Maximum step size of fixed step size
                           #              integrators, if > 0.0
       4                   # Algorithm    Integration algorithm as integer (1...28)
                           #
                           #             | model|       |        | dense | state |
                           # Algorithm   | typ  | stiff | order  | output| event |
                           # ------------+------+-------+--------+-------+-------+
                           #  1 | deabm  |  ode |   no  |  1-12  |  yes  |   no  |
                           #  2 | lsode1 |  ode |   no  |  1-12  |  yes  |   no  |
                           #  3 | lsode2 |  ode |  yes  |  1-5   |  yes  |   no  |
                           #  4 | lsodar |  ode |  both |1-12,1-5|  yes  |  yes  |
                           #  5 | dopri5 |  ode |   no  |   5    |   no  |   no  |
                           #  6 | dopri8 |  ode |   no  |   8    |   no  |   no  |
                           #  7 | grk4t  |  ode |  yes  |   4    |   no  |   no  |
                           #  8 | dassl  |  dae |  yes  |  1-5   |  yes  |  yes  |
                           #  9 | odassl | hdae |  yes  |  1-5   |  yes  |  yes  |
                           # 10 | mexx   | hdae |   no  |  2-24  |   no  |   no  |
                           # 11 | euler  |  ode |   no  |   1    |   no  |  yes  |
                           # 12 | rkfix2 |  ode |   no  |   2    |   no  |  yes  |
                           # 13 | rkfix3 |  ode |   no  |   3    |   no  |  yes  |
                           # 14 | rkfix4 |  ode |   no  |   4    |   no  |  yes  |
                           #>=14| others |  ode |yes/no |  2-5   |   yes |  yes  |
                           # ---+--------+------+-------+--------+-------+-------+
                           # euler and rkfix have fixed stepsize.


#    Method tuning parameters
double method(27,1)
       1                   # grid     type of communication time grid, defined by
                           #          = 1: equidistant points ("Increment/nInterval")
                           #          = 2: vector of grid points ("tgrid")
                           #          = 3: variable step integrator (automatically)
                           #          = 4: model (call of "increment" in Dymola, e.g.
                           #                      incr=Time > 2 then 0 else 0.1
                           #                      dummy=increment(incr))
                           #          grid = 1,3 is stopped by "StopTime"
                           #          grid = 2   is stopped by "tgrid(last)"
                           #          grid = 4   runs forever (stopped by model)
       1                   # nt       Use every NT time instant, if grid = 3
       3                   # dense    1/2/3 restart/step/interpolate GRID points
       1                   # evgrid   0/1 do not/save event points in comm. time grid
       1                   # evu      0/1 U-discontinuity does not/trigger events
       0                   # evuord       U-discontinuity order to consider (0,1,...)
       0                   # error    0/1/2 One message/warning/error messages
       0                   # jac      0/1 Compute jacobian numerically/by BLOCKJ
       0                   # xd0c     0/1 Compute/set XD0
       0                   # f3       0/1 Ignore/use F3 of HDAE (= index 1)
       0                   # f4       0/1 Ignore/use F4 of HDAE (= index 2)
       0                   # f5       0/1 Ignore/use F5 of HDAE (= invar.)
       0                   # debug    flags for debug information (1<<0 uses pdebug) 
     100                   # pdebug       priority of debug information (1...100)
       0                   # fmax     Maximum number of evaluations of BLOCKF, if > 0
       0                   # ordmax   Maximum allowed integration order, if > 0
       0                   # hmax     Maximum absolute stepsize, if > 0
       0                   # hmin     Minimum absolute stepsize, if > 0 (use with care!)
       0                   # h0       Stepsize to be attempted on first step, if > 0
  1.000000000000000E-012   # teps     Bound to check, if 2 equal time instants
  1.000000000000000E-010   # eveps    Hysteresis epsilon at event points
      20                   # eviter   Maximum number of event iterations
       0                   # delaym   Minimum time increment in delay buffers
       1                   # fexcep   0/1 floating exception crashes/stops dymosim
       1                   # tscale   clock-time = tscale*simulation-time, if grid = 5
                           #          > 1: simulation too slow
                           #          = 1: simulation-time = real-time
                           #          < 1: simulation too fast
       1                   # shared   (not used)
    2473                   # memkey   (not used)


#    Output parameters
int settings(13,1)
 0                         # lprec    0/1 do not/store result data in double
 1                         # lx       0/1 do not/store x  (state variables)
 0                         # lxd      0/1 do not/store xd (derivative of states)
 1                         # lu       0/1 do not/store u  (input     signals)
 1                         # ly       0/1 do not/store y  (output    signals)
 0                         # lz       0/1 do not/store z  (indicator signals)
 1                         # lw       0/1 do not/store w  (auxiliary signals)
 1                         # la       0/1 do not/store a  (alias     signals)
 0                         # lperf    0/1 do not/store performance indicators
 0                         # levent   0/1 do not/store event point
 1                         # lres     0/1 do not/store results on result file
 0                         # lshare   0/1 do not/store info data for shared memory on dsshare.txt
 1                         # lform    0/1 ASCII/Matlab-binary storage format of results
                           #              (for simulation/linearization; not for trimming)


#    Names of initial variables
char initialName(137,53)
failureTrigger.realFaultSize
failureTrigger.integerFaultSize
failureTrigger.booleanFaultSize
failureTrigger.realFault[1]
failureTrigger.integerFault[1]
failureTrigger.booleanFault[1]
failureTrigger.booleanFault[2]
MotorSpeed
quadraticSpeedDependentTorque.useSupport
quadraticSpeedDependentTorque.flange.tau
quadraticSpeedDependentTorque.phi_support
quadraticSpeedDependentTorque.phi
quadraticSpeedDependentTorque.der(phi)
quadraticSpeedDependentTorque.tau_nominal
quadraticSpeedDependentTorque.TorqueDirection
quadraticSpeedDependentTorque.w_nominal
IntegerFailureInput[1]
BooleanFailureInput[1]
BooleanFailureInput[2]
RealFailureInput[1]
motor.motor.useSupport
motor.motor.flange.tau
motor.motor.phi_support
motor.bokenKt.k
motor.halfBrokenKt.k
motor.flange1.tau
motor.motorInertia.J
motor.motorInertia.stateSelect
motor.motorInertia.phi
motor.motorInertia.w
motor.motorInertia.der(w)
motor.kt_selection.nin
motor.kt_selection.y
motor.kt_selection.allowOutOfRange
motor.kt_selection.outOfRangeValue
motor.kt_selection.index
motor.kt_selection.k[1]
motor.kt_selection.k[2]
motor.kt_selection.k[3]
motor.multiplex.n1
motor.multiplex.n2
motor.multiplex.n3
motor.healthyKt.k
motor.speedSensor.flange.tau
motor.speedSensor.fault_local
motor.speedSensor.externalFault.faultIndex
motor.speedSensor.externalFault.externalFaultOn
motor.speedSensor.fault
motor.motorTorqueReference.k
motor.motorKtFailure.fault_local
motor.motorKtFailure.externalFault.faultIndex
motor.motorKtFailure.externalFault.externalFaultOn
driveline.DriveFriction.realFault
driveline.DriveFriction.fault_local
driveline.DriveFriction.externalFault.faultIndex
driveline.DriveFriction.externalFault.externalFaultOn
driveline.DrivelineDisconnect.k
driveline.booleanToReal.realTrue
driveline.booleanToReal.realFalse
driveline.booleanToReal.y
driveline.Driveline_Break.phi_rel
driveline.Driveline_Break.der(phi_rel)
driveline.Driveline_Break.w_rel
driveline.Driveline_Break.der(w_rel)
driveline.Driveline_Break.tau
driveline.Driveline_Break.flange_a.phi
driveline.Driveline_Break.flange_a.der(phi)
driveline.Driveline_Break.flange_a.der(phi, 2)
driveline.Driveline_Break.phi_nominal
driveline.Driveline_Break.stateSelect
driveline.Driveline_Break.mue_pos[1, 1]
driveline.Driveline_Break.mue_pos[1, 2]
driveline.Driveline_Break.peak
driveline.Driveline_Break.cgeo
driveline.Driveline_Break.fn_max
driveline.Driveline_Break.w_small
driveline.Driveline_Break.tau0
driveline.Driveline_Break.tau0_max
driveline.Driveline_Break.free
driveline.Driveline_Break.sa
driveline.Driveline_Break.startForward
driveline.Driveline_Break.startBackward
driveline.Driveline_Break.locked
driveline.Driveline_Break.Unknown
driveline.Driveline_Break.Free
driveline.Driveline_Break.Forward
driveline.Driveline_Break.Stuck
driveline.Driveline_Break.Backward
driveline.Driveline_Break.mode
driveline.Driveline_Break.unitAngularAcceleration
driveline.Driveline_Break.unitTorque
driveline.Driveline_Break.useHeatPort
driveline.Driveline_Break.lossPower
driveline.Driveline_Break.fn
driveline.inertia.flange_b.tau
driveline.inertia.J
driveline.inertia.stateSelect
driveline.inertia.w
driveline.inertia.der(w)
driveline.brake.useSupport
driveline.brake.phi_support
driveline.brake.mue_pos[1, 1]
driveline.brake.mue_pos[1, 2]
driveline.brake.peak
driveline.brake.cgeo
driveline.brake.fn_max
driveline.brake.w_small
driveline.brake.tau0
driveline.brake.tau0_max
driveline.brake.free
driveline.brake.sa
driveline.brake.startForward
driveline.brake.startBackward
driveline.brake.locked
driveline.brake.Unknown
driveline.brake.Free
driveline.brake.Forward
driveline.brake.Stuck
driveline.brake.Backward
driveline.brake.mode
driveline.brake.unitAngularAcceleration
driveline.brake.unitTorque
driveline.brake.useHeatPort
driveline.brake.lossPower
driveline.brake.tau
driveline.brake.fn
driveline.idealGear.useSupport
driveline.idealGear.phi_support
driveline.idealGear.ratio
driveline.SpeedSensor.flange.tau
driveline.SpeedSensor.fault_local
driveline.SpeedSensor.externalFault.faultIndex
driveline.SpeedSensor.externalFault.externalFaultOn
driveline.SpeedSensor.fault
ActuatorSpeed
DymolaConvertInputToReal1
DymolaConvertInputToReal2

double initialValue(137,6)
  0       1                       1                  1.000000000000000E+100
  6   258   # failureTrigger.realFaultSize
  0       1                       1                  1.000000000000000E+100
  6   258   # failureTrigger.integerFaultSize
  0       2                       1                  1.000000000000000E+100
  6   258   # failureTrigger.booleanFaultSize
  0       0                       0                       0                
  6   256   # failureTrigger.realFault[1]
  0       0                       0                       0                
  6   322   # failureTrigger.integerFault[1]
  0       0                       0                       0                
  6   321   # failureTrigger.booleanFault[1]
  0       0                       0                       0                
  6   321   # failureTrigger.booleanFault[2]
  0       0                       0                       0                
  4   256   # MotorSpeed
  0       0                       0                       0                
  6   769   # quadraticSpeedDependentTorque.useSupport
  0       0                       0                       0                
  6   388   # quadraticSpeedDependentTorque.flange.tau
  0       0                       0                       0                
  6  1280   # quadraticSpeedDependentTorque.phi_support
 -1       0                       0                       0                
  2   280   # quadraticSpeedDependentTorque.phi
  0       0                       0                       0                
  3   256   # quadraticSpeedDependentTorque.der(phi)
 -1 -1.000000000000000E-001       0                       0                
  1   280   # quadraticSpeedDependentTorque.tau_nominal
  0       1                       0                       0                
  6   257   # quadraticSpeedDependentTorque.TorqueDirection
 -1       1                  1.000000000000000E-015  1.000000000000000E+100
  1   280   # quadraticSpeedDependentTorque.w_nominal
 -1       0                       0                       0                
  5   322   # IntegerFailureInput[1]
 -1       0                       0                       0                
  5   321   # BooleanFailureInput[1]
 -1       0                       0                       0                
  5   321   # BooleanFailureInput[2]
 -1       0                       0                       0                
  5   256   # RealFailureInput[1]
  0       0                       0                       0                
  6   769   # motor.motor.useSupport
  0       0                       0                       0                
  6   452   # motor.motor.flange.tau
  0       0                       0                       0                
  6  1280   # motor.motor.phi_support
 -1       0                       0                       0                
  1   280   # motor.bokenKt.k
 -1  5.000000000000000E-001       0                       0                
  1   280   # motor.halfBrokenKt.k
  0       0                       0                       0                
  6   388   # motor.flange1.tau
 -1  1.000000000000000E-003       0                  1.000000000000000E+100
  1   280   # motor.motorInertia.J
  0       3                       1                       5                
  6   770   # motor.motorInertia.stateSelect
  0       0                       0                       0                
  6   256   # motor.motorInertia.phi
  0       0                       0                       0                
  6   256   # motor.motorInertia.w
  0       0                       0                       0                
  6   256   # motor.motorInertia.der(w)
  0       3                       0                       0                
  6   258   # motor.kt_selection.nin
  0       0                       0                       0                
  6   320   # motor.kt_selection.y
 -1       0                       0                       0                
  1   281   # motor.kt_selection.allowOutOfRange
 -1  1.000000000000000E+010       0                       0                
  1   280   # motor.kt_selection.outOfRangeValue
  0       0                       0                       0                
  6   330   # motor.kt_selection.index
  0       0                       0                       0                
  6  1344   # motor.kt_selection.k[1]
  0       0                       0                       0                
  6  1344   # motor.kt_selection.k[2]
  0       0                       0                       0                
  6  1344   # motor.kt_selection.k[3]
  0       1                       0                       0                
  6   258   # motor.multiplex.n1
  0       1                       0                       0                
  6   258   # motor.multiplex.n2
  0       1                       0                       0                
  6   258   # motor.multiplex.n3
 -1       1                       0                       0                
  1   280   # motor.healthyKt.k
  0       0                       0                       0                
  6   388   # motor.speedSensor.flange.tau
 -1       0                       0                       0                
  1   281   # motor.speedSensor.fault_local
 -1       1                       0                       0                
  1   282   # motor.speedSensor.externalFault.faultIndex
 -1       1                       0                       0                
  1   281   # motor.speedSensor.externalFault.externalFaultOn
  0       0                       0                       0                
  6   321   # motor.speedSensor.fault
 -1       1                       0                       0                
  1   280   # motor.motorTorqueReference.k
 -1       1                       0                       0                
  1   282   # motor.motorKtFailure.fault_local
 -1       1                       0                       0                
  1   282   # motor.motorKtFailure.externalFault.faultIndex
 -1       0                       0                       0                
  1   281   # motor.motorKtFailure.externalFault.externalFaultOn
  0       0                       0                       0                
  6   256   # driveline.DriveFriction.realFault
 -1       0                       0                       0                
  1   280   # driveline.DriveFriction.fault_local
 -1       1                       0                       0                
  1   282   # driveline.DriveFriction.externalFault.faultIndex
 -1       0                       0                       0                
  1   281   # driveline.DriveFriction.externalFault.externalFaultOn
 -1       0                       0                       0                
  1   281   # driveline.DrivelineDisconnect.k
 -1       0                       0                       0                
  1   280   # driveline.booleanToReal.realTrue
 -1       1                       0                       0                
  1   280   # driveline.booleanToReal.realFalse
  0       0                       0                       0                
  6   256   # driveline.booleanToReal.y
 -1       0                       0                       0                
  2   280   # driveline.Driveline_Break.phi_rel
  0       0                       0                       0                
  3   256   # driveline.Driveline_Break.der(phi_rel)
 -1       0                       0                       0                
  2   280   # driveline.Driveline_Break.w_rel
  0       0                       0                       0                
  3   256   # driveline.Driveline_Break.der(w_rel)
  0       0                       0                       0                
  6   256   # driveline.Driveline_Break.tau
  0       0                       0                       0                
  6   260   # driveline.Driveline_Break.flange_a.phi
  0       0                       0                       0                
  6   260   # driveline.Driveline_Break.flange_a.der(phi)
  0       0                       0                       0                
  6   260   # driveline.Driveline_Break.flange_a.der(phi, 2)
  0  1.000000000000000E-004       0                       0                
  6   256   # driveline.Driveline_Break.phi_nominal
  0       4                       1                       5                
  6   770   # driveline.Driveline_Break.stateSelect
 -1       0                       0                       0                
  1   280   # driveline.Driveline_Break.mue_pos[1, 1]
 -1  5.000000000000000E-001       0                       0                
  1   280   # driveline.Driveline_Break.mue_pos[1, 2]
 -1       1                       1                  1.000000000000000E+100
  1   280   # driveline.Driveline_Break.peak
 -1       1                       0                  1.000000000000000E+100
  1   280   # driveline.Driveline_Break.cgeo
 -1     100                       0                  1.000000000000000E+100
  1   280   # driveline.Driveline_Break.fn_max
 -1  1.000000000000000E+010       0                       0                
  1   280   # driveline.Driveline_Break.w_small
  0       0                       0                       0                
  6   256   # driveline.Driveline_Break.tau0
  0       0                       0                       0                
  6   256   # driveline.Driveline_Break.tau0_max
  0       0                       0                       0                
  6   257   # driveline.Driveline_Break.free
  0       0                       0                       0                
  6   256   # driveline.Driveline_Break.sa
  0       0                       0                       0                
  6   361   # driveline.Driveline_Break.startForward
  0       0                       0                       0                
  6   361   # driveline.Driveline_Break.startBackward
  0       0                       0                       0                
  6   353   # driveline.Driveline_Break.locked
  0       3                       0                       0                
  6   258   # driveline.Driveline_Break.Unknown
  0       2                       0                       0                
  6   258   # driveline.Driveline_Break.Free
  0       1                       0                       0                
  6   258   # driveline.Driveline_Break.Forward
  0       0                       0                       0                
  6   258   # driveline.Driveline_Break.Stuck
  0      -1                       0                       0                
  6   258   # driveline.Driveline_Break.Backward
  0       3                      -1                       3                
  6   330   # driveline.Driveline_Break.mode
  0       1                       0                       0                
  6   768   # driveline.Driveline_Break.unitAngularAcceleration
  0       1                       0                       0                
  6   768   # driveline.Driveline_Break.unitTorque
  0       0                       0                       0                
  6   769   # driveline.Driveline_Break.useHeatPort
  0       0                       0                       0                
  6   256   # driveline.Driveline_Break.lossPower
  0       0                       0                       0                
  6   256   # driveline.Driveline_Break.fn
  0       0                       0                       0                
  6   388   # driveline.inertia.flange_b.tau
 -1  1.000000000000000E-003       0                  1.000000000000000E+100
  1   280   # driveline.inertia.J
  0       3                       1                       5                
  6   770   # driveline.inertia.stateSelect
 -1       0                       0                       0                
  2   280   # driveline.inertia.w
  0       0                       0                       0                
  3   256   # driveline.inertia.der(w)
  0       0                       0                       0                
  6   769   # driveline.brake.useSupport
  0       0                       0                       0                
  6  1280   # driveline.brake.phi_support
 -1       0                       0                       0                
  1   280   # driveline.brake.mue_pos[1, 1]
 -1  5.000000000000000E-001       0                       0                
  1   280   # driveline.brake.mue_pos[1, 2]
 -1       1                       1                  1.000000000000000E+100
  1   280   # driveline.brake.peak
 -1       1                       0                  1.000000000000000E+100
  1   280   # driveline.brake.cgeo
 -1     100                       0                  1.000000000000000E+100
  1   280   # driveline.brake.fn_max
 -1  1.000000000000000E+010       0                       0                
  1   280   # driveline.brake.w_small
  0       0                       0                       0                
  6   256   # driveline.brake.tau0
  0       0                       0                       0                
  6   256   # driveline.brake.tau0_max
  0       0                       0                       0                
  6   321   # driveline.brake.free
  0       0                       0                       0                
  6   256   # driveline.brake.sa
  0       0                       0                       0                
  6   361   # driveline.brake.startForward
  0       0                       0                       0                
  6   361   # driveline.brake.startBackward
  0       0                       0                       0                
  6   353   # driveline.brake.locked
  0       3                       0                       0                
  6   258   # driveline.brake.Unknown
  0       2                       0                       0                
  6   258   # driveline.brake.Free
  0       1                       0                       0                
  6   258   # driveline.brake.Forward
  0       0                       0                       0                
  6   258   # driveline.brake.Stuck
  0      -1                       0                       0                
  6   258   # driveline.brake.Backward
  0       3                      -1                       3                
  6   330   # driveline.brake.mode
  0       1                       0                       0                
  6   768   # driveline.brake.unitAngularAcceleration
  0       1                       0                       0                
  6   768   # driveline.brake.unitTorque
  0       0                       0                       0                
  6   769   # driveline.brake.useHeatPort
  0       0                       0                       0                
  6   256   # driveline.brake.lossPower
  0       0                       0                       0                
  6   256   # driveline.brake.tau
  0       0                       0                       0                
  6   256   # driveline.brake.fn
  0       0                       0                       0                
  6   769   # driveline.idealGear.useSupport
  0       0                       0                       0                
  6  1280   # driveline.idealGear.phi_support
 -1       2                       0                       0                
  1   280   # driveline.idealGear.ratio
  0       0                       0                       0                
  6   388   # driveline.SpeedSensor.flange.tau
 -1       0                       0                       0                
  1   281   # driveline.SpeedSensor.fault_local
 -1       2                       0                       0                
  1   282   # driveline.SpeedSensor.externalFault.faultIndex
 -1       1                       0                       0                
  1   281   # driveline.SpeedSensor.externalFault.externalFaultOn
  0       0                       0                       0                
  6   321   # driveline.SpeedSensor.fault
  0       0                       0                       0                
  4   256   # ActuatorSpeed
  0       0                       0                       0                
  6   832   # DymolaConvertInputToReal1
  0       0                       0                       0                
  6   832   # DymolaConvertInputToReal2


# Matrix with 6 columns defining the initial value calculation
# (columns 5 and 6 are not utilized for the calculation but are
#  reported by dymosim via dymosim -i for user convenience):
#
# column 1: Type of initial value
#           = -2: special case: for continuing simulation (column 2 = value)
#           = -1: fixed value (column 2 = fixed value)
#           =  0: free value, i.e., no restriction (column 2 = initial value)
#           >  0: desired value (column 1 = weight for optimization
#                                column 2 = desired value)
#                 use weight=1, since automatic scaling usually
#                 leads to equally weighted terms
# column 2: fixed, free or desired value according to column 1.
# column 3: Minimum value (ignored, if Minimum >= Maximum).
# column 4: Maximum value (ignored, if Minimum >= Maximum).
#           Minimum and maximum restrict the search range in initial
#           value calculation. They might also be used for scaling.
# column 5: Category of variable.
#           = 1: parameter.
#           = 2: state.
#           = 3: state derivative.
#           = 4: output.
#           = 5: input.
#           = 6: auxiliary variable.
# column 6: Data type of variable.
#           = 0: real.
#           = 1: boolean.
#           = 2: integer.
#
# Initial values are calculated according to the following procedure:
#
# - If parameters, states and inputs are FIXED, and other variables
#   are FREE, no special action takes place (default setting).
#
# - If there are only FIXED and FREE variables and the number of
#   FREE parameters, states and inputs is IDENTICAL to the number of
#   FIXED state derivatives, outputs and auxiliary variables, a non-linear
#   equation is solved to determine a consistent set of initial conditions.
#
# - In all other cases the following optimization problem is solved:
#      min( sum( weight(i)*( (value(i) - DESIRED(i))/scale(i) )^2 ) )
#   under the constraint that the differential equation is fulfilled
#   at the initial time. In most cases weight(i)=1 is sufficient, due
#   to the automatic scaling (if DESIRED(i) is not close to zero,
#   scale(i) = DESIRED(i). Otherwise, the scaling is based on the
#   nominal value (and maybe minimum and maximum values given in 
#   column 3 and 4). If these values are zero, scale(i)=1 is used).
#
char initialDescription(137,152)



Real Failure trigger
Integer Failure trigger
Boolean Failure trigger
Boolean Failure trigger
Absolute angular velocity of flange
= true, if support flange enabled, otherwise implicitly grounded
Cut torque in the flange [N.m]
Absolute angle of support flange [rad|deg]
Angle of flange with respect to support (= flange.phi - support.phi) [rad|deg]
der(Angle of flange with respect to support (= flange.phi - support.phi)) [rad/s]
Nominal torque (if negative, torque is acting as load) [N.m]
Same direction of torque in both directions of rotation
Nominal speed [rad/s]
Connector of Real input signals
Connector of Real input signals
Connector of Real input signals
Connector of Real input signals
= true, if support flange enabled, otherwise implicitly grounded
Cut torque in the flange [N.m]
Absolute angle of support flange [rad|deg]
Constant output value
Constant output value
Cut torque in the flange [N.m]
Moment of inertia [kg.m2]
Priority to use phi and w as states
Absolute rotation angle of component [rad|deg]
Absolute angular velocity of component (= der(phi)) [rad/s]
der(Absolute angular velocity of component (= der(phi))) [rad/s2]
Number of inputs
Connector of Real output signal
Index may be out of range
Output signal if index is out of range




dimension of input signal connector 1
dimension of input signal connector 2
dimension of input signal connector 3
Constant output value
Cut torque in the flange [N.m]
Default fault value if not external triggering is used
Full name of model parameter
Component Name
Final failure value
Constant output value
Default fault value if not external triggering is used
Full name of model parameter
Component Name

Default fault value if not external triggering is used
Full name of model parameter
Component Name
Constant output value
Output signal for true Boolean input
Output signal for false Boolean input
Connector of Real output signal
Relative rotation angle (= flange_b.phi - flange_a.phi) [rad|deg]
der(Relative rotation angle (= flange_b.phi - flange_a.phi)) [rad/s]
Relative angular velocity (= der(phi_rel)) [rad/s]
der(Relative angular velocity (= der(phi_rel))) [rad/s2]
Torque between flanges (= flange_b.tau) [N.m]
Absolute rotation angle of flange [rad|deg]
der(Absolute rotation angle of flange) [rad/s]
der(Absolute rotation angle of flange, 2) [rad/s2]
Nominal value of phi_rel (used for scaling) [rad|rad]
Priority to use phi_rel and w_rel as states
[w,mue] positive sliding friction coefficient (w_rel>=0)
[w,mue] positive sliding friction coefficient (w_rel>=0)
peak*mue_pos[1,2] = maximum value of mue for w_rel==0
Geometry constant containing friction distribution assumption
Maximum normal force [N]
Relative angular velocity near to zero if jumps due to a reinit(..) of the velocity can occur (set to low value only if such impulses can occur) [rad/s]
Friction torque for w=0 and forward sliding [N.m]
Maximum friction torque for w=0 and locked [N.m]
true, if frictional element is not active
Path parameter of friction characteristic tau = f(a_relfric) [1]
true, if w_rel=0 and start of forward sliding
true, if w_rel=0 and start of backward sliding
true, if w_rel=0 and not sliding
Value of mode is not known
Element is not active
w_rel > 0 (forward sliding)
w_rel = 0 (forward sliding, locked or backward sliding)
w_rel < 0 (backward sliding)

[rad/s2]
[N.m]
=true, if heatPort is enabled
Loss power leaving component via heatPort (> 0, if heat is flowing out of component) [W]
Normal force (fn=fn_max*f_normalized) [N]
Cut torque in the flange [N.m]
Moment of inertia [kg.m2]
Priority to use phi and w as states
Absolute angular velocity of component (= der(phi)) [rad/s]
der(Absolute angular velocity of component (= der(phi))) [rad/s2]
= true, if support flange enabled, otherwise implicitly grounded
Absolute angle of support flange [rad|deg]
[w,mue] positive sliding friction coefficient (w_rel>=0)
[w,mue] positive sliding friction coefficient (w_rel>=0)
peak*mue_pos[1,2] = maximum value of mue for w_rel==0
Geometry constant containing friction distribution assumption
Maximum normal force [N]
Relative angular velocity near to zero if jumps due to a reinit(..) of the velocity can occur (set to low value only if such impulses can occur) [rad/s]
Friction torque for w=0 and forward sliding [N.m]
Maximum friction torque for w=0 and locked [N.m]
true, if frictional element is not active
Path parameter of friction characteristic tau = f(a_relfric) [1]
true, if w_rel=0 and start of forward sliding
true, if w_rel=0 and start of backward sliding
true, if w_rel=0 and not sliding
Value of mode is not known
Element is not active
w_rel > 0 (forward sliding)
w_rel = 0 (forward sliding, locked or backward sliding)
w_rel < 0 (backward sliding)

[rad/s2]
[N.m]
=true, if heatPort is enabled
Loss power leaving component via heatPort (> 0, if heat is flowing out of component) [W]
Brake friction torqu [N.m]
Normal force (=fn_max*f_normalized) [N]
= true, if support flange enabled, otherwise implicitly grounded
Absolute angle of support flange [rad|deg]
Transmission ratio (flange_a.phi/flange_b.phi)
Cut torque in the flange [N.m]
Default fault value if not external triggering is used
Full name of model parameter
Component Name
Final failure value
Absolute angular velocity of flange



